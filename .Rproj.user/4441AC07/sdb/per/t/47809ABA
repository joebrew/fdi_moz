{
    "contents" : "\n##### SHARED LEGEND FOR MULTIPLE PLOTS GGPLOT2\n# https://github.com/hadley/ggplot2/wiki/Share-a-legend-between-two-ggplot2-graphs\ngrid_arrange_shared_legend <- function(...) {\n  plots <- list(...)\n  g <- ggplotGrob(plots[[1]] + theme(legend.position=\"bottom\"))$grobs\n  legend <- g[[which(sapply(g, function(x) x$name) == \"guide-box\")]]\n  lheight <- sum(legend$height)\n  grid.arrange(\n    do.call(arrangeGrob, lapply(plots, function(x)\n      x + theme(legend.position=\"none\"))),\n    legend,\n    ncol = 1,\n    heights = unit.c(unit(1, \"npc\") - lheight, lheight))\n}\n\n#####\n# EXTRACT JUST THE LEGEND\n# http://stackoverflow.com/questions/12539348/ggplot-separate-legend-and-plot\ng_legend<-function(a.gplot){\n  tmp <- ggplot_gtable(ggplot_build(a.gplot))\n  leg <- which(sapply(tmp$grobs, function(x) x$name) == \"guide-box\")\n  legend <- tmp$grobs[[leg]]\n  legend\n}\n\n##### CONFIDENCE INTERVALS ON PROPORTIONS\n# (https://aghaynes.wordpress.com/2014/04/09/calculating-confidence-intervals-for-proportions/)\nsimpasym <- function(n, p, z=1.96, cc=TRUE){\n  out <- list()\n  if(cc){\n    out$lb <- p - z*sqrt((p*(1-p))/n) - 0.5/n\n    out$ub <- p + z*sqrt((p*(1-p))/n) + 0.5/n\n  } else {\n    out$lb <- p - z*sqrt((p*(1-p))/n)\n    out$ub <- p + z*sqrt((p*(1-p))/n)\n  }\n  out\n}\n\n\ncapwords <- function(s, strict = FALSE) {\n  cap <- function(s) paste(toupper(substring(s, 1, 1)),\n                           {s <- substring(s, 2); if(strict) tolower(s) else s},\n                           sep = \"\", collapse = \" \" )\n  sapply(strsplit(s, split = \" \"), cap, USE.NAMES = !is.null(names(s)))\n}\n\nlibrary(reshape2)\n\nmultiplot <- function(..., plotlist = NULL, file, cols = 1, layout = NULL) {\n  require(grid)\n  \n  plots <- c(list(...), plotlist)\n  \n  numPlots = length(plots)\n  \n  if (is.null(layout)) {\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                     ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n  \n  if (numPlots == 1) {\n    print(plots[[1]])\n    \n  } else {\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n    \n    for (i in 1:numPlots) {\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n      \n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}\n\n#####\n# KEEP ONLY N LEVELS OF A CATEGORICAL VARIABLE\n# (AND ASSIGN ALL OTHER LEVELS TO SOMETHING ELSE)\n#####\nsimplify <- function(var, n = 10, other = NA, empty_as_other = FALSE){\n  var <- as.character(var)\n  if(empty_as_other){\n    var[which(var == '')] <- other\n  }\n  x <- as.data.frame(table(var)); x <- x[rev(order(x$Freq)),]\n  keeps <- x$var[1:n]\n  var <- ifelse(var %in% keeps, var, other)\n  var <- factor(var)\n  return(var)\n}\n\n\n# COLLAPSE SHAPEFILE INTO ONE POLYGON\ncollapse_map <- function(x){\n  boundary <- unionSpatialPolygons(x, rep(1, length(x@polygons)))\n  return(boundary)\n}\n\n\n#####\n# GET EUCLIDEAN DISTANCE IN KM\n#####\nget_distance <- function(lon1, \n                         lat1, \n                         lon2, \n                         lat2){\n  rad <- pi/180\n  a1 <- lat1 * rad\n  a2 <- lon1 * rad\n  b1 <- lat2 * rad\n  b2 <- lon2 * rad\n  dlon <- b2 - a2\n  dlat <- b1 - a1\n  a <- (sin(dlat/2))^2 + cos(a1) * cos(b1) * (sin(dlon/2))^2\n  c <- 2 * atan2(sqrt(a), sqrt(1 - a))\n  R <- 6378.145\n  d <- R * c\n  return(d)\n}\n",
    "created" : 1443185617993.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "219791522",
    "id" : "47809ABA",
    "lastKnownWriteTime" : 1443185635,
    "path" : "~/Documents/fdi_moz/helpers.R",
    "project_path" : "helpers.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}